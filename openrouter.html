<!DOCTYPE html>
<html>
  <head>
    <title>editor</title>
    <style>
      :root{color-scheme:light dark}
      *{box-sizing:border-box}
      body{overflow:hidden}
      main{display:flex;flex-direction:column}
      iframe,textarea{flex:2}
      html,body,main{width:101%;height:100%;margin:0}
      textarea{font-family:monospace;white-space:pre-wrap}
    </style>
  </head>
  <body>
    <main>
      <iframe></iframe>
      <textarea></textarea>
    </main>
    <script>
      class Editor{
        constructor(n,d){
          [this.name,this.store,this.db]=[n,n,d]
          ;[this.t,this.f]=['textarea','iframe'].map(s=>document.querySelector(s))
          this.c=new BroadcastChannel('editor-sync')
        }
        static async create(n){
          const d=await new Promise((r,j)=>{
            const q=indexedDB.open(n,2)
            q.onupgradeneeded=e=>e.target.result.createObjectStore(n,{keyPath:'key'})
            q.onsuccess=e=>r(e.target.result)
            q.onerror=e=>j(e.target.errorCode)
          })
          const e=new Editor(n,d)
          await e.handleParams()
          e.bind()
          location.hash||='#home'
          await e.load()
          e.t.focus()
          return e
        }
    
        async op(m,k,v){
          const s=this.db.transaction(this.store,m).objectStore(this.store)
          return v?s.put({key:k,value:v}):new Promise(r=>s.get(k).onsuccess=e=>r(e.target.result?.value))
        }
    
        async handleParams(){
          const p=new URLSearchParams(location.search)
          if(p.has('prompt')){
            const k=localStorage.getItem('api.key')||localStorage.setItem('api.key',prompt('OpenRouter API Key:'))
            const r=await fetch('https://openrouter.ai/api/v1/chat/completions',{
              method:'POST',headers:{'Authorization':'Bearer '+k,'Content-Type':'application/json'},
              body:JSON.stringify({model:localStorage.getItem('api.model')||'openai/gpt-3.5-turbo',messages:[{role:'user',content:p.get('prompt')}]})
            }).then(r=>r.json())
            this.t.value=r.choices[0].message.content
            await this.save()
          }
          for(const i of p.getAll('install')){
            const[k,c]=i.split(',')
            if(k&&c&&(!await this.op('readonly',k)||confirm('Overwrite '+k+'?')))
              await this.op('readwrite',k,decodeURIComponent(c))
          }
          history.replaceState(null,'',location.pathname+location.hash)
        }
    
        bind(){
          this.t.oninput=()=>{cancelAnimationFrame(this._s);this._s=requestAnimationFrame(()=>this.save())}
          onhashchange=()=>this.load()
          this.c.onmessage=({data:[k,v]})=>k===(location.hash.slice(1)||'home')&&(this.t.value=v)
          onbeforeunload=()=>this.c.close()
        }
    
        async save(){
          const k=location.hash.slice(1)||'home'
          if(!['source','reset'].includes(k)){
            const v=this.t.value
            await this.op('readwrite',k,v)
            this.c.postMessage([k,v])
          }
        }
    
        async load(){
          const h=location.hash.slice(1)||'home'
          const i=await Promise.all((new URLSearchParams(location.search).get('import')||'').split(',').map(k=>this.op('readonly',k)))
          const c=await this.op('readonly',h)
          this.t.value=c||''
          this.update([...i,c].join(''))
        }
    
        update(c){
          const d=this.f.contentDocument
          d?.write(`<!DOCTYPE html><style>:root{color-scheme:light dark}*{white-space:pre-wrap;box-sizing:border-box}</style>${c}`)
          d?.close()
        }
      }
    
      Editor.create('editor')
    </script>
  </body>
</html>
